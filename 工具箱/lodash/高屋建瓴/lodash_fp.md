## key

> lodash/fp: produce immutable auto-curried iteratee-first data-last methods

## use

Mapping：

- Fixed Arity: Methods have fixed arities to support auto-currying. => 有>=2个参数作为前提条件
- Rearranged Arguments: Method arguments are rearranged to make composition easier. => 参数的顺序调整，使得组合更加简单
- Capped Iteratee Arguments: Iteratee arguments are capped to avoid gotchas with variadic iteratees. => 迭代函数做参时，捕获的参数和参数个数
- No Optional Arguments: Optional arguments are not supported by auto-curried methods. => 可选参数要显示传入

Placeholders：

- `_`占位符，可以去调整lodash/fp指定的顺序

Chaining：

- [Why using `_.chain` is a mistake](https://medium.com/bootstart/why-using-chain-is-a-mistake-9bc1f80d51ba)



### Chaining

上面链接里面作者分析使用`chain`存在连个问题。



问题一：`chain` 的返回对象（chain wrapper），可链接的方法要提前在`_`上准备好

```javascript
_.chain = (array) => wrap(array, _); // Rough concept of chain
```

要么全局导入，但在浏览器端可能存在体积过大、不必要的问题（现在来看可能是过时了）：

```javascript
import _ from "lodash"; // Import everything.
```

要么手动包装一个`_`，这就很麻烦了：

```javascript
import chain from "lodash/chain";
import value from "lodash/value";
import map from "lodash/map";
import mixin from "lodash/mixin";
import _ from "lodash/wrapperLodash";// Add the methods you want. The object generated by chain() will
// now have these methods.
mixin(_, {map: map, chain: chain, value: value});_.chain([1,2,3]).map(x => x+1).value(); // Use the methods.
```



问题二：要在这个链式加入自定义的方法，有点麻烦：

```javascript
//动全局对象
import _ from "lodash";
_.mixin({vowels:vowels});
_.chain(['ab','cd','ef']).vowels().value(); // Use the methods.
```

```javascript
//用管道的方法，每个需要单独包一层
import _ from "lodash";
_.chain(['ab','cd','ef']).thru(vowels).value();
```



亮点来了。作者分析`chain`提供的价值其实就是Function currying、Function composition。找到能提供相同价值的能力，就可以替换掉`chain`。

Lodash/FP开箱即用的 auto-curried，`flow`方法的函数组合能力。所以：

```javascript
import map from "lodash/fp/map";
import flatten from "lodash/fp/flatten";
import sortBy from "lodash/fp/sortBy";
import flow from "lodash/fp/flow";

flow(
  map(x => [x, x*2]), 
  flatten, 
  sortBy(x => x)
)([1, 2, 3]);
```



最后的最后，作者用webpack打包，去对比了两种方式的时间和大小。这是非常细致的。



总结：从中后台场景来看，使用全局导入lodash和`chain`来实现链式，问题不大。但是作者这种探究的方式，非常值得借鉴。

## link

[Lodash wiki FP Guide](https://github.com/lodash/lodash/wiki/FP-Guide)

[What is Lodash/fp, even?](https://dev.to/ifarmgolems/what-is-lodash-fp-even-4ohd?signin=true)